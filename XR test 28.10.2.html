<script>
/* ====== KeyShotXR autorotate (robust probe) ====== */
(function () {
  // ---- tune speed here ----
  var SECONDS_PER_TURN = 4;     // ~4s per revolution
  var uCountFallback   = 192;   // used to compute step timing if we can't read it
  var PX_PER_MOVE      = 6;     // pixels per synthetic move when faking drag
  var START_DELAY_MS   = 600;   // give KS a moment to bind handlers
  // -------------------------

  var wrapperId = 'KeyShotXR';
  var timer = null, stopped = false, mode = 'unknown';
  var uIndex = 0;

  function wrap() { return document.getElementById(wrapperId); }
  function canvas() {
    var w = wrap();
    if (!w) return null;
    var c = w.querySelector('canvas');
    return c || w;
  }

  function getUCount() {
    try {
      if (typeof keyshotXR !== 'undefined') {
        if (Number.isFinite(keyshotXR.m_uCount)) return keyshotXR.m_uCount;
        if (Number.isFinite(keyshotXR.uCount))   return keyshotXR.uCount;
      }
    } catch(e){}
    return uCountFallback;
  }

  function getUIndex() {
    try {
      if (typeof keyshotXR !== 'undefined') {
        if (Number.isFinite(keyshotXR.m_uIndex)) return keyshotXR.m_uIndex;
        if (Number.isFinite(keyshotXR.uIndex))   return keyshotXR.uIndex;
      }
    } catch(e){}
    return null; // unknown
  }

  function setFrameDirect(u, v) {
    try {
      if (keyshotXR && typeof keyshotXR.setViewIndex === 'function') { keyshotXR.setViewIndex(u|0, v|0); return true; }
      if (keyshotXR && typeof keyshotXR.setCurrentIndex === 'function') { keyshotXR.setCurrentIndex(u|0, v|0); return true; }
      if (keyshotXR && typeof keyshotXR.SetIndex === 'function') { keyshotXR.SetIndex(u|0, v|0); return true; }
      if (keyshotXR) {
        var changed = false;
        if ('m_uIndex' in keyshotXR) { keyshotXR.m_uIndex = u|0; changed = true; }
        if ('m_vIndex' in keyshotXR) { keyshotXR.m_vIndex = (v|0); }
        if (changed && typeof keyshotXR.update === 'function') { keyshotXR.update(); return true; }
        if (changed && typeof keyshotXR.render === 'function') { keyshotXR.render(); return true; }
      }
    } catch(e){}
    return false;
  }

  // --- event helpers ---
  function dispatch(el, type, opts) {
    if (!el) return;
    var base = { bubbles:true, cancelable:true };
    var e;
    if (window.PointerEvent) {
      e = new PointerEvent(type, Object.assign({ pointerId:1, pointerType:'mouse', isPrimary:true }, base, opts||{}));
      el.dispatchEvent(e);
      return;
    }
    // Mouse fallback
    var mouseType = type.replace('pointer','mouse');
    e = new MouseEvent(mouseType, Object.assign({ buttons: (type.indexOf('down')>=0 || (opts&&opts.buttons===1)) ? 1 : 0 }, base, opts||{}));
    el.dispatchEvent(e);
  }

  function beginHold(el, x, y) {
    dispatch(el, 'pointerdown', { clientX:x, clientY:y, buttons:1, pressure:0.5 });
  }
  function moveHold(el, x, y) {
    dispatch(el, 'pointermove', { clientX:x, clientY:y, buttons:1, pressure:0.5 });
  }
  function endHold(el, x, y) {
    dispatch(el, 'pointerup',   { clientX:x, clientY:y, buttons:0, pressure:0 });
  }

  // --- stop on real interaction ---
  function attachUserStop() {
    var w = wrap(); if (!w) return;
    ['pointerdown','mousedown','touchstart','wheel','keydown'].forEach(function(evt){
      w.addEventListener(evt, function(){ if (!stopped) stop(); }, { once:true, passive:true });
    });
  }

  function stop() {
    stopped = true;
    if (timer) { clearInterval(timer); timer = null; }
    try { endHold(canvas()); } catch(e){}
  }

  // --- probe a mode for 500ms to see if uIndex changes ---
  function probe(modeName, stepFn, done) {
    var c = canvas(); if (!c) return done(false);
    var r = c.getBoundingClientRect();
    var x = Math.round(r.left + r.width/2), y = Math.round(r.top + r.height/2);

    var startU = getUIndex();
    var ticks = 0;
    var localTimer = setInterval(function(){
      if (stopped) { clearInterval(localTimer); return done(false); }
      ticks++;
      stepFn(c, x, y);
      var nowU = getUIndex();
      if (nowU !== null && startU !== null && nowU !== startU) {
        clearInterval(localTimer);
        mode = modeName;
        return done(true);
      }
      if (ticks > 15) { clearInterval(localTimer); done(false); }
    }, 30);
  }

  // Strategies
  function strat_pointer_hold_step(c, x, y, state) {
    if (!state.started) { beginHold(c, x, y); state.started = true; }
    x += PX_PER_MOVE; moveHold(c, x, y);
    state.x = x; state.y = y;
  }
  function strat_pointer_pulse_step(c, x, y) {
    beginHold(c, x, y); x += PX_PER_MOVE; moveHold(c, x, y); endHold(c, x, y);
  }
  function strat_mouse_hold_step(c, x, y, state) { strat_pointer_hold_step(c, x, y, state); }
  function strat_mouse_pulse_step(c, x, y) { strat_pointer_pulse_step(c, x, y); }
  function strat_touch_pulse_step(c, x, y) {
    // synthesize touch via pointer fallback already handled; pulse again anyway
    strat_pointer_pulse_step(c, x, y);
  }

  function startAutorotate() {
    if (stopped) return;

    var uCount = getUCount();
    var msPerStep = Math.max(16, Math.round((SECONDS_PER_TURN * 1000) / uCount));

    // Try direct stepping first (best quality)
    var directOk = setFrameDirect((uIndex+1)%uCount, 0);
    if (directOk) {
      mode = 'direct';
      timer = setInterval(function(){
        if (stopped) return;
        uIndex = (uIndex + 1) % uCount;
        setFrameDirect(uIndex, 0);
      }, msPerStep);
      return;
    }

    // Otherwise probe which synthetic scheme works, then run it
    var schemes = [
      { name:'pointer-hold', step:function(c,x,y,st){ strat_pointer_hold_step(c,x,y,st); }, state:{} },
      { name:'pointer-pulse', step:strat_pointer_pulse_step },
      { name:'mouse-hold',   step:function(c,x,y,st){ strat_mouse_hold_step(c,x,y,st); }, state:{} },
      { name:'mouse-pulse',  step:strat_mouse_pulse_step },
      { name:'touch-pulse',  step:strat_touch_pulse_step }
    ];

    (function tryNext(i){
      if (stopped) return;
      if (i >= schemes.length) { mode = 'failed'; return; }

      var s = schemes[i];
      probe(s.name, function(c,x,y){ s.step(c,x,y,s.state||{}); }, function(success){
        if (success) {
          // Run steady-state
          var c = canvas(); if (!c) return;
          var r = c.getBoundingClientRect();
          var x = Math.round(r.left + r.width/2), y = Math.round(r.top + r.height/2);
          if (s.name.indexOf('hold')>=0) beginHold(c, x, y);
          timer = setInterval(function(){
            if (stopped) return;
            s.step(c, x, y, s.state||{});
            x += PX_PER_MOVE; // keep creeping x so deltas are non-zero
          }, msPerStep);
        } else {
          tryNext(i+1);
        }
      });
    })(0);
  }

  window.addEventListener('load', function(){
    attachUserStop();
    setTimeout(startAutorotate, START_DELAY_MS);
  });

  document.addEventListener('visibilitychange', function(){
    if (document.hidden) { stop(); }
    else if (!stopped) { setTimeout(startAutorotate, 200); }
  });
})();
</script>
