<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Studs — 360 (fast, no strobe, drag)</title>
  <style>
    body{margin:0;background:#000;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .wrap{width:min(92vw,1000px);margin:24px auto;text-align:center}
    #view{width:100%;height:auto;touch-action:none;user-select:none}
    #status{color:#bbb;margin-top:8px;font-size:14px}
  </style>
</head>
<body>
  <div class="wrap">
    <img id="view" alt="360 view (drag to rotate)" decoding="async" fetchpriority="high"/>
    <div id="status">Loading…</div>
  </div>

  <script>
    // ===== YOUR FRAMES =====
    const folder = 'XR test 28.10.2';  // note the space
    const TOTAL  = 192;                 // 0_0.jpg ... 0_191.jpg
    const TURN_S = 4;                   // seconds per full turn
    // =======================

    const base = encodeURIComponent(folder).replace(/%2F/g,'/');
    const urls = Array.from({length: TOTAL}, (_,i) => `${base}/0_${i}.jpg`);

    const img    = document.getElementById('view');
    const status = document.getElementById('status');

    // Cache and load state
    const cache = new Array(TOTAL);          // Image() objects once loaded
    const loaded = new Array(TOTAL).fill(false);
    let loadedCount = 0;

    // Concurrency-limited loader
    const MAX_CONCURRENT = 8;
    let inFlight = 0, q = [];
    function loadFrame(i){
      return new Promise(res => {
        const run = () => {
          inFlight++;
          const im = new Image();
          im.decoding = 'async';
          im.onload = () => { cache[i] = im; loaded[i] = true; loadedCount++; inFlight--; pump(); res(true); };
          im.onerror = () => { inFlight--; pump(); res(false); };
          im.src = urls[i]; // let CDN cache; no cache-bust
        };
        if (inFlight < MAX_CONCURRENT) run(); else q.push(run);
      });
    }
    function pump(){ while (inFlight < MAX_CONCURRENT && q.length) q.shift()(); }

    // Playback state
    let frame = 0;
    let playing = true;
    let lastTs = 0;

    function stepMs(){ return 1000 / (TOTAL / TURN_S); }

    // Advance to the next **loaded** frame; if none yet, stay on current
    function nextLoadedIndex(i){
      for (let k = 1; k <= TOTAL; k++){
        const j = (i + k) % TOTAL;
        if (loaded[j]) return j;
      }
      return i; // nothing else loaded yet
    }

    function setFrame(i){
      frame = ((i % TOTAL) + TOTAL) % TOTAL;
      if (loaded[frame]) img.src = cache[frame].src;
      // else: keep showing the last displayed image (prevents black strobe)
    }

    function tick(ts){
      if (!playing) return;
      if (!lastTs) lastTs = ts;
      if (ts - lastTs >= stepMs()){
        const j = nextLoadedIndex(frame);
        setFrame(j);
        lastTs = ts;
      }
      requestAnimationFrame(tick);
    }

    // Drag (pointer + mouse/touch fallback)
    function attachDrag(){
      let dragging = false;
      let lastX = 0;
      const pxPerFrame = 6; // sensitivity: lower = faster

      const onDown = (clientX, pointerId) => {
        playing = false; // stop autoplay on first interaction
        dragging = true;
        lastX = clientX;
        if (pointerId != null) img.setPointerCapture(pointerId);
        status.textContent = 'Drag to rotate.';
      };

      img.addEventListener('pointerdown', (e)=>{
        onDown(e.clientX, e.pointerId);
      });
      img.addEventListener('pointermove', (e)=>{
        if (!dragging) return;
        const dx = e.clientX - lastX; lastX = e.clientX;
        const steps = Math.trunc(dx / pxPerFrame);
        if (steps) setFrame(frame - steps);
      });
      img.addEventListener('pointerup',   ()=> dragging = false);
      img.addEventListener('pointercancel',()=> dragging = false);

      // Fallback for browsers with no pointer events
      img.addEventListener('mousedown', (e)=> onDown(e.clientX, null));
      window.addEventListener('mousemove', (e)=>{
        if (!dragging) return;
        const dx = e.clientX - lastX; lastX = e.clientX;
        const steps = Math.trunc(dx / pxPerFrame);
        if (steps) setFrame(frame - steps);
      });
      window.addEventListener('mouseup', ()=> dragging = false);

      img.addEventListener('touchstart', (e)=>{
        if (!e.touches.length) return;
        onDown(e.touches[0].clientX, null);
      }, {passive:true});
      img.addEventListener('touchmove', (e)=>{
        if (!dragging || !e.touches.length) return;
        const x = e.touches[0].clientX;
        const dx = x - lastX; lastX = x;
        const steps = Math.trunc(dx / pxPerFrame);
        if (steps) setFrame(frame - steps);
      }, {passive:true});
      img.addEventListener('touchend', ()=> dragging = false);
    }

    document.addEventListener('visibilitychange', ()=>{
      if (document.hidden) playing = false;
      else { playing = true; lastTs = 0; requestAnimationFrame(tick); }
    });

    (async function start(){
      // Load frame 0 first, show it
      await loadFrame(0);
      setFrame(0);
      status.textContent = 'Loading frames…';

      // Begin preloading everything (round-robin near current frame)
      // This pattern fills neighbors first, so autoplay finds loaded frames quickly
      const order = [];
      for (let radius = 1; radius < TOTAL; radius++){
        const f1 = (0 + radius) % TOTAL;
        const f2 = (0 - radius + TOTAL) % TOTAL;
        if (order.indexOf(f1) === -1) order.push(f1);
        if (order.indexOf(f2) === -1) order.push(f2);
      }
      order.forEach(i => loadFrame(i));

      // Start autoplay + drag
      playing = true;
      lastTs = 0;
      requestAnimationFrame(tick);
      attachDrag();

      // Progress indicator
      const prog = setInterval(()=>{
        const pct = Math.round(loadedCount / TOTAL * 100);
        status.textContent = `Loaded ${pct}% — drag to rotate.`;
        if (pct >= 100) { clearInterval(prog); status.textContent = 'Loaded 100%. Drag to rotate.'; }
      }, 300);
    })();
  </script>
</body>
</html>
